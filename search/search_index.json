{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"htmlobj Documentation This site contains the project documentation for the htmlobj project. Table Of Contents Getting Started Reference Release Notes","title":"Index"},{"location":"#htmlobj-documentation","text":"This site contains the project documentation for the htmlobj project.","title":"htmlobj Documentation"},{"location":"#table-of-contents","text":"Getting Started Reference Release Notes","title":"Table Of Contents"},{"location":"getting_started/","text":"Getting Started Overview htmlobj allows you to create HTML using nothing but Python code. It is an alternative to using templates, as used in many web frameworks, which usually have their own non-Python language. With htmlobj , you can just create the HTML objects directly in code, and return the str representation to the web engine. Using Python with statements to build the htmlobj objects allows you to easily see the HTML structure, and add in any Python code you need. When complete, the str value of the object will return HTML text. Here is a brief example: from htmlobj import HTML h = HTML(\"html\") with h.table(border=\"1\", style=\"border-collapse:collapse\"): with h.tr: h.td(\"cell 1\") h.td(\"cell 2\") h.p.u(\"List\") with h.ul as mylist: # optional `as` var name for i in range(3): mylist.li(f\"Item {i}\") print(h) # show `str` representation -> '<table><tr><td>cell 1</td>...' When rendered in a browser, the result will look something like: Not the prettiest web page, but of course you can add CSS, class_ and other attributes to style the output. See the simple_page.py example in the source code for a more complex version of the above, including links, CSS classes and styles. Installing pip install htmlobj Auto-generate code If you have a web page with content similar to what you want, you can directly create a Python file from the command line by running htmlobj.html_parser with python -m : python -m htmlobj.html_parser https://example.com > my_code.py Alternatively, you can do the same thing in code using from_url and codify : h = HTML.from_url(\"https://example.com/\") print(h.codify()) either method gives output like h = HTML() with h.html: with h.head: h.title(\"Example Domain\") h.meta(charset=\"utf-8\") h.meta(http-equiv=\"Content-type\", content=\"text/html; charset=utf-8\") ... You can then edit the code as needed. More details You may supply a tag name and some text contents when creating a HTML instance: >>> h = HTML('html', 'text') >>> print(h) <html>text</html> You may also append text content later using the tag's .text() method or using augmented addition += . Any HTML-specific characters ( <>&\" ) in the text will be escaped for HTML safety as appropriate unless escape=False is passed. Each of the following examples uses a new HTML instance: >>> p = h.p('hello world!\\\\n') >>> p.br >>> p.text('more &rarr; text', escape=False) >>> p += ' ... augmented' >>> h.p >>> print(h) <p>hello, world!<br>more &rarr; text ... augmented</p> <p> Note: You can also use raw_text as a shortcut for text('text', escape=False) . The top-level HTML object adds newlines between tags by default. Finally in the above you'll see an empty paragraph tag - tags with no contents get no closing tag. You may turn off/on adding newlines by passing newlines=False or True to the tag (or HTML instance) at creation time: >>> l = h.ol(newlines=False) >>> l.li('item 1') >>> l.li('item 2') >>> print(h) <ol><li>item 1</li><li>item 2</li></ol> Since we can't use class in Python code (it is a reserved Python keyword), the library recognises class_ or klass as a substitute: >>> print(h.p(content, class_=\"styled\")) # or print(h.p(content, klass=\"styled\")) <p class=\"styled\">content</p> How generation works The HTML document is generated when the HTML instance is \"stringified\". This could be done either by invoking str() on it, or just printing it. It may also be returned directly as the \"iterable content\" from a WSGI app function. You may also render any tag or sub-tag at any time by stringifying it. Tags with no contents (either text or sub-tags) will have no closing tag. There is no \"special list\" of tags that must always have closing tags, so if you need to force a closing tag you'll need to provide some content, even if it's just a single space character. Rendering doesn't affect the HTML document's state, so you can add to or otherwise manipulate the HTML after you've stringified it. Creating XHTML To construct XHTML start with an instance of htmlobj.XHTML() and use it as you would an HTML instance. Empty elements will now be rendered with the appropriate XHTML minimized tag syntax. For example: >>> from htmlobj import XHTML >>> h = XHTML() >>> h.p >>> h.br >>> print(h) <p></p> <br /> Creating XML A slight tweak to the htmlobj.XHTML() implementation allows us to generate arbitrary XML using htmlobj.XML() : >>> from htmlobj import XML >>> h = XML('xml') >>> h.p >>> h.br('hi there') >>> print(h) <xml> <p /> <br>hi there</br> </xml> Tags with difficult names If your tag name isn't a valid Python identifier name, or if it's called \"text\" or \"raw_text\" you can add your tag slightly more manually: >>> from htmlobj import XML >>> h = XML('xml') >>> h += XML('some-tag', 'some text') >>> h += XML('text', 'some text') >>> print(h) <xml> <some-tag>some text</some-tag> <text>some text</text> </xml>","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#overview","text":"htmlobj allows you to create HTML using nothing but Python code. It is an alternative to using templates, as used in many web frameworks, which usually have their own non-Python language. With htmlobj , you can just create the HTML objects directly in code, and return the str representation to the web engine. Using Python with statements to build the htmlobj objects allows you to easily see the HTML structure, and add in any Python code you need. When complete, the str value of the object will return HTML text. Here is a brief example: from htmlobj import HTML h = HTML(\"html\") with h.table(border=\"1\", style=\"border-collapse:collapse\"): with h.tr: h.td(\"cell 1\") h.td(\"cell 2\") h.p.u(\"List\") with h.ul as mylist: # optional `as` var name for i in range(3): mylist.li(f\"Item {i}\") print(h) # show `str` representation -> '<table><tr><td>cell 1</td>...' When rendered in a browser, the result will look something like: Not the prettiest web page, but of course you can add CSS, class_ and other attributes to style the output. See the simple_page.py example in the source code for a more complex version of the above, including links, CSS classes and styles.","title":"Overview"},{"location":"getting_started/#installing","text":"pip install htmlobj","title":"Installing"},{"location":"getting_started/#auto-generate-code","text":"If you have a web page with content similar to what you want, you can directly create a Python file from the command line by running htmlobj.html_parser with python -m : python -m htmlobj.html_parser https://example.com > my_code.py Alternatively, you can do the same thing in code using from_url and codify : h = HTML.from_url(\"https://example.com/\") print(h.codify()) either method gives output like h = HTML() with h.html: with h.head: h.title(\"Example Domain\") h.meta(charset=\"utf-8\") h.meta(http-equiv=\"Content-type\", content=\"text/html; charset=utf-8\") ... You can then edit the code as needed.","title":"Auto-generate code"},{"location":"getting_started/#more-details","text":"You may supply a tag name and some text contents when creating a HTML instance: >>> h = HTML('html', 'text') >>> print(h) <html>text</html> You may also append text content later using the tag's .text() method or using augmented addition += . Any HTML-specific characters ( <>&\" ) in the text will be escaped for HTML safety as appropriate unless escape=False is passed. Each of the following examples uses a new HTML instance: >>> p = h.p('hello world!\\\\n') >>> p.br >>> p.text('more &rarr; text', escape=False) >>> p += ' ... augmented' >>> h.p >>> print(h) <p>hello, world!<br>more &rarr; text ... augmented</p> <p> Note: You can also use raw_text as a shortcut for text('text', escape=False) . The top-level HTML object adds newlines between tags by default. Finally in the above you'll see an empty paragraph tag - tags with no contents get no closing tag. You may turn off/on adding newlines by passing newlines=False or True to the tag (or HTML instance) at creation time: >>> l = h.ol(newlines=False) >>> l.li('item 1') >>> l.li('item 2') >>> print(h) <ol><li>item 1</li><li>item 2</li></ol> Since we can't use class in Python code (it is a reserved Python keyword), the library recognises class_ or klass as a substitute: >>> print(h.p(content, class_=\"styled\")) # or print(h.p(content, klass=\"styled\")) <p class=\"styled\">content</p>","title":"More details"},{"location":"getting_started/#how-generation-works","text":"The HTML document is generated when the HTML instance is \"stringified\". This could be done either by invoking str() on it, or just printing it. It may also be returned directly as the \"iterable content\" from a WSGI app function. You may also render any tag or sub-tag at any time by stringifying it. Tags with no contents (either text or sub-tags) will have no closing tag. There is no \"special list\" of tags that must always have closing tags, so if you need to force a closing tag you'll need to provide some content, even if it's just a single space character. Rendering doesn't affect the HTML document's state, so you can add to or otherwise manipulate the HTML after you've stringified it.","title":"How generation works"},{"location":"getting_started/#creating-xhtml","text":"To construct XHTML start with an instance of htmlobj.XHTML() and use it as you would an HTML instance. Empty elements will now be rendered with the appropriate XHTML minimized tag syntax. For example: >>> from htmlobj import XHTML >>> h = XHTML() >>> h.p >>> h.br >>> print(h) <p></p> <br />","title":"Creating XHTML"},{"location":"getting_started/#creating-xml","text":"A slight tweak to the htmlobj.XHTML() implementation allows us to generate arbitrary XML using htmlobj.XML() : >>> from htmlobj import XML >>> h = XML('xml') >>> h.p >>> h.br('hi there') >>> print(h) <xml> <p /> <br>hi there</br> </xml>","title":"Creating XML"},{"location":"getting_started/#tags-with-difficult-names","text":"If your tag name isn't a valid Python identifier name, or if it's called \"text\" or \"raw_text\" you can add your tag slightly more manually: >>> from htmlobj import XML >>> h = XML('xml') >>> h += XML('some-tag', 'some text') >>> h += XML('text', 'some text') >>> print(h) <xml> <some-tag>some text</some-tag> <text>some text</text> </xml>","title":"Tags with difficult names"},{"location":"reference/","text":"Reference htmlobj . HTML ( name = None , text = None , stack = None , newlines = True , escape = True ) Easily generate HTML. h = HTML() with h.table: with h.tr: h.td(\"cell 1\") h.td(\"cell 2\") h.p.u(\"List\") with h.ul: for i in range(3): h.li(f\"Item {i}\") print(h) Output: '<table><tr><td>cell 1</td>...' Create a new HTML instance Parameters: name ( str | None ) \u2013 html tag name to start with. Defaults to None. text ( str | None ) \u2013 Text for inside html tag. Defaults to None. stack ( list | None ) \u2013 Internal use - stack of contents. Defaults to None. newlines ( bool ) \u2013 Whether to put newlines in string output. Defaults to True. escape ( bool ) \u2013 Whether to 'escape' special html characters. Defaults to True. newline_default_on = set ( 'table ol ul dl span html head body ' . split ()) instance-attribute class-attribute html tags which use newlines by default __call__ ( * content , ** kw ) 'Magic method' called when adding attrs in brackets e.g. h.tag(...) Raises: TypeError \u2013 if called with read (problem with some WSGI providers) Returns: HTML ( HTML ) \u2013 A reference to this HTML instance __iadd__ ( other ) Operator for += . Add content to the current HTML object Parameters: other ( str | HTML ) \u2013 text, or HTML instance to add Returns: HTML ( HTML ) \u2013 A reference to this instance codify () Turn the HTML object into Python code Returns: str ( str ) \u2013 Python code to generate this HTML instance Note codify is usually used when the HTML instance has been created using from_url or from_html from_html ( html ) classmethod Parse the given html string and return a corresponding instance of this class Parameters: html ( str ) \u2013 The html text to create the htmlobj.HTML instance from Returns: HTML ( HTML ) \u2013 A new instance of the HTML class from_url ( url ) classmethod Parse the HTML from the given url and return a new instance of this class Parameters: url ( str ) \u2013 A web-site url as accepted by urllib Returns: HTML ( HTML ) \u2013 a new instance of the HTML class raw_text ( text ) Add raw, unescaped text to the HTML object. Parameters: text ( str ) \u2013 The text to add inside the html tag Returns: HTML ( HTML ) \u2013 A reference to this HTML instance text ( text , escape = True ) Add text to the current HTML object. Parameters: text ( str ) \u2013 The text to add inside the html tag escape ( bool ) \u2013 Whether to 'escape' the html for special characters. Defaults to True. htmlobj.XHTML Bases: HTML Easily generate XHTML. Tags in empty_elements are self-terminated. Example: >>> from htmlobj import XHTML >>> h = XHTML() >>> h.p >>> h.br >>> print(h) <p></p> <br /> empty_elements = set ( 'base meta link hr br param img area input col colgroup basefont isindex frame' . split ()) instance-attribute class-attribute Elements which can be self-closing, e.g. <br /> htmlobj.XML Bases: XHTML Easily generate XML. All tags with no contents are reduced to self-terminating tags. Example: >>> from htmlobj import XML >>> h = XML('xml') >>> h.p >>> h.br('hi there') >>> print(h) <xml> <p /> <br>hi there</br> </xml>","title":"Reference"},{"location":"reference/#reference","text":"","title":"Reference"},{"location":"reference/#htmlobj.HTML","text":"Easily generate HTML. h = HTML() with h.table: with h.tr: h.td(\"cell 1\") h.td(\"cell 2\") h.p.u(\"List\") with h.ul: for i in range(3): h.li(f\"Item {i}\") print(h) Output: '<table><tr><td>cell 1</td>...' Create a new HTML instance Parameters: name ( str | None ) \u2013 html tag name to start with. Defaults to None. text ( str | None ) \u2013 Text for inside html tag. Defaults to None. stack ( list | None ) \u2013 Internal use - stack of contents. Defaults to None. newlines ( bool ) \u2013 Whether to put newlines in string output. Defaults to True. escape ( bool ) \u2013 Whether to 'escape' special html characters. Defaults to True.","title":"HTML"},{"location":"reference/#htmlobj.htmlobj.HTML.newline_default_on","text":"html tags which use newlines by default","title":"newline_default_on"},{"location":"reference/#htmlobj.htmlobj.HTML.__call__","text":"'Magic method' called when adding attrs in brackets e.g. h.tag(...) Raises: TypeError \u2013 if called with read (problem with some WSGI providers) Returns: HTML ( HTML ) \u2013 A reference to this HTML instance","title":"__call__()"},{"location":"reference/#htmlobj.htmlobj.HTML.__iadd__","text":"Operator for += . Add content to the current HTML object Parameters: other ( str | HTML ) \u2013 text, or HTML instance to add Returns: HTML ( HTML ) \u2013 A reference to this instance","title":"__iadd__()"},{"location":"reference/#htmlobj.htmlobj.HTML.codify","text":"Turn the HTML object into Python code Returns: str ( str ) \u2013 Python code to generate this HTML instance Note codify is usually used when the HTML instance has been created using from_url or from_html","title":"codify()"},{"location":"reference/#htmlobj.htmlobj.HTML.from_html","text":"Parse the given html string and return a corresponding instance of this class Parameters: html ( str ) \u2013 The html text to create the htmlobj.HTML instance from Returns: HTML ( HTML ) \u2013 A new instance of the HTML class","title":"from_html()"},{"location":"reference/#htmlobj.htmlobj.HTML.from_url","text":"Parse the HTML from the given url and return a new instance of this class Parameters: url ( str ) \u2013 A web-site url as accepted by urllib Returns: HTML ( HTML ) \u2013 a new instance of the HTML class","title":"from_url()"},{"location":"reference/#htmlobj.htmlobj.HTML.raw_text","text":"Add raw, unescaped text to the HTML object. Parameters: text ( str ) \u2013 The text to add inside the html tag Returns: HTML ( HTML ) \u2013 A reference to this HTML instance","title":"raw_text()"},{"location":"reference/#htmlobj.htmlobj.HTML.text","text":"Add text to the current HTML object. Parameters: text ( str ) \u2013 The text to add inside the html tag escape ( bool ) \u2013 Whether to 'escape' the html for special characters. Defaults to True.","title":"text()"},{"location":"reference/#htmlobj.XHTML","text":"Bases: HTML Easily generate XHTML. Tags in empty_elements are self-terminated. Example: >>> from htmlobj import XHTML >>> h = XHTML() >>> h.p >>> h.br >>> print(h) <p></p> <br />","title":"XHTML"},{"location":"reference/#htmlobj.xhtml.XHTML.empty_elements","text":"Elements which can be self-closing, e.g. <br />","title":"empty_elements"},{"location":"reference/#htmlobj.XML","text":"Bases: XHTML Easily generate XML. All tags with no contents are reduced to self-terminating tags. Example: >>> from htmlobj import XML >>> h = XML('xml') >>> h.p >>> h.br('hi there') >>> print(h) <xml> <p /> <br>hi there</br> </xml>","title":"XML"},{"location":"release%20notes/","text":"Release Notes v1.20.0 Added HTML.from_html and HTML.from_url methods to create an HTML instance from an existing HTML source Added HTML.codify method to produce Python code from an HTML instance. In combination with one of the HTML.from_ methods, can make Python code to reproduce existing HTML similar to what you need. Added ability to handle 'blank' attrs like 'nowrap' using e.g. nowrap=None attribute. Added class_ as alternative to klass in avoiding Python's class keyword Release notes from html3 and html libaries 1.18 Fixed support of python 3.8 1.17 First release of html3 1.16 detect and raise a more useful error when some WSGI frameworks attempt to call HTML.read(). Also added ability to add new content using the += operator. 1.15 fix Python 3 compatibility (unit tests) 1.14 added plain XML support 1.13 allow adding (X)HTML instances (tags) as new document content 1.12 fix handling of XHTML empty tags when generating unicode output (thanks Carsten Eggers) 1.11 remove setuptools dependency 1.10 support plain ol' distutils again 1.9 added unicode support for Python 2.x 1.8 added Python 3 compatibility 1.7 added Python 2.5 compatibility and escape argument to tag construction 1.6 added .raw_text() and and WSGI compatibility 1.5 added XHTML support 1.3 added more documentation, more tests 1.2 added special-case klass / class attribute 1.1 added escaping control 1.0 was the initial release","title":"Release Notes"},{"location":"release%20notes/#release-notes","text":"","title":"Release Notes"},{"location":"release%20notes/#v1200","text":"Added HTML.from_html and HTML.from_url methods to create an HTML instance from an existing HTML source Added HTML.codify method to produce Python code from an HTML instance. In combination with one of the HTML.from_ methods, can make Python code to reproduce existing HTML similar to what you need. Added ability to handle 'blank' attrs like 'nowrap' using e.g. nowrap=None attribute. Added class_ as alternative to klass in avoiding Python's class keyword","title":"v1.20.0"},{"location":"release%20notes/#release-notes-from-html3-and-html-libaries","text":"1.18 Fixed support of python 3.8 1.17 First release of html3 1.16 detect and raise a more useful error when some WSGI frameworks attempt to call HTML.read(). Also added ability to add new content using the += operator. 1.15 fix Python 3 compatibility (unit tests) 1.14 added plain XML support 1.13 allow adding (X)HTML instances (tags) as new document content 1.12 fix handling of XHTML empty tags when generating unicode output (thanks Carsten Eggers) 1.11 remove setuptools dependency 1.10 support plain ol' distutils again 1.9 added unicode support for Python 2.x 1.8 added Python 3 compatibility 1.7 added Python 2.5 compatibility and escape argument to tag construction 1.6 added .raw_text() and and WSGI compatibility 1.5 added XHTML support 1.3 added more documentation, more tests 1.2 added special-case klass / class attribute 1.1 added escaping control 1.0 was the initial release","title":"Release notes from html3 and html libaries"}]}